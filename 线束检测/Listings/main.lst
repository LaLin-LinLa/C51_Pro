C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2024 01:15:55 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Apps\Keil5_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1            #include <STC15F2K60S2.H>
   2            #include <stdio.h>
   3            #include <stdarg.h>
   4            #include <intrins.h>
   5          
   6            /*总线矩阵检测*/
   7            sbit SA1 = P3^5;
   8            sbit SA2 = P3^6;
   9            sbit SA3 = P3^7;
  10            sbit SA4 = P4^1;
  11          
  12            sbit SB1 = P4^2;
  13            sbit SB2 = P4^3;
  14            sbit SB3 = P4^4;
  15            sbit SB4 = P2^0;
  16          
  17            sbit SC1 = P2^4;
  18            sbit SC2 = P2^5;
  19            sbit SC3 = P2^6;
  20            sbit SC4 = P2^7;
  21          
  22            sbit SD1 = P4^5;
  23            sbit SD2 = P4^6;
  24            sbit SD3 = P0^0;
  25            sbit SD4 = P0^1;
  26          
  27            sbit SE1 = P0^2;
  28            sbit SE2 = P0^3;
  29            sbit SE3 = P0^4;
  30          
  31            sbit A0  = P5^4;
  32            sbit A1  = P1^7;
  33            sbit A2  = P5^5;
  34          
  35            sbit B0  = P3^2;
  36            sbit B1  = P4^0;
  37            sbit B2  = P3^3;
  38          
  39            sbit C0  = P2^2;
  40            sbit C1  = P2^1;
  41            sbit C2  = P2^3;
  42          
  43            sbit D0  = P0^6;
  44            sbit D1  = P0^5;
  45            sbit D2  = P0^7;
  46          
  47            sbit E0  = P1^2;
  48            sbit E1  = P4^7;
  49            sbit E2  = P1^3;
  50          
  51            #define NONE_PARITY     0       //无校验
  52            #define ODD_PARITY      1       //奇校验
  53            #define EVEN_PARITY     2       //偶校验
  54            #define MARK_PARITY     3       //标记校验
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2024 01:15:55 PAGE 2   

  55            #define SPACE_PARITY    4       //空白校验
  56            
  57            #define S1_S0 0x40              //P_SW1.6
  58            #define S1_S1 0x80              //P_SW1.7
  59            #define S2_S0 0x01              //P_SW2.0
  60            #define S2RI  0x01              //S2CON.0
  61            #define S2TI  0x02              //S2CON.1
  62            #define S2RB8 0x04              //S2CON.2
  63            #define S2TB8 0x08              //S2CON.3
  64          
  65            #define BOOT    0x00    //空闲
  66            #define STEP    0x01    //单步检测
  67            #define ROLL    0x02    //滚动检测
  68            #define DEBUG   0x03    //开关debug
  69            #define HELP    0x04    //命令帮助
  70            #define REBOOT  0x05    //重启
  71            #define AUTO    0x06    //自动检测
  72          
  73            #define FOSC 11059200L          //系统频率
  74          
  75            #define UART1_IO          0       //定义串口1IO口复用选择
  76            #define UART1_PARITYBIT NONE_PARITY     //定义校验位
  77            #define UART1_BODE    9600        //串口波特率
  78            
  79            #define UART2_IO          0       //定义串口2IO口复用选择
  80            #define UART2_PARITYBIT NONE_PARITY     //定义校验位
  81            #define UART2_BODE    9600        //串口波特率
  82          
  83            #define REPORT  UART2_SendString
  84            #define PRINTF  UART1_SendData
  85            
  86            static unsigned char err  = 0;
  87            static unsigned char err_last  = 0;
  88            static bit f_debug = 0;
  89            static bit tx1_busy = 0;
  90            static bit tx2_busy = 0;
  91            int line = -1;
  92            int line_last = -1;
  93            int bus[4];   
  94            int pos[5];
  95            unsigned char cmd = ROLL;
  96            unsigned char cmd_last = ROLL;
  97          
  98          
  99            //延时函数us
 100            void delay_us(unsigned int t)
 101            {
 102   1          while(t)
 103   1          {
 104   2            _nop_();
 105   2            _nop_();
 106   2            _nop_();
 107   2            t--;
 108   2          }
 109   1        }
 110            //延时函数ms
 111            void delay_ms(unsigned int t)
 112            {
 113   1          unsigned char i, j;
 114   1          while(t)
 115   1          {
 116   2            _nop_();
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2024 01:15:55 PAGE 3   

 117   2            _nop_();
 118   2            _nop_();
 119   2            i = 11;
 120   2            j = 190;
 121   2            do
 122   2            {
 123   3              while (--j);
 124   3            } while (--i);
 125   2            t--;
 126   2          }
 127   1        }
 128          
 129            //串口1初始化
 130            void Init_uart1(unsigned int baud){
 131   1          
 132   1          #if (UART1_IO == 0)
 133   1          {
 134   2            ACC = P_SW1;
 135   2            ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
 136   2            P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
 137   2          }
 138   1          #elif (UART1_IO == 1)
                  {
                    ACC = P_SW1;
                    ACC &= ~(S1_S0 | S1_S1);    //S1_S0=1 S1_S1=0
                    ACC |= S1_S0;               //(P3.6/RxD_2, P3.7/TxD_2)
                    P_SW1 = ACC;  
                  }
                  #elif (UART1_IO == 2)
                  {
                    ACC = P_SW1;
                    ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=1
                    ACC |= S1_S1;               //(P1.6/RxD_3, P1.7/TxD_3)
                    P_SW1 = ACC;  
                  }
                  #endif
 153   1          
 154   1          #if (UART1_PARITYBIT == NONE_PARITY)
 155   1              SCON = 0x50;                //8位可变波特率
 156   1          #elif (UART1_PARITYBIT == ODD_PARITY) || (UART1_PARITYBIT == EVEN_PARITY) || (UART1_PARITYBIT == MARK_PA
             -RITY)
                      SCON = 0xda;                //9位可变波特率,校验位初始为1
                  #elif (UART1_PARITYBIT == SPACE_PARITY)
                      SCON = 0xd2;                //9位可变波特率,校验位初始为0
                  #endif
 161   1          
 162   1          AUXR |= 0x40;                //定时器1为1T模式
 163   1          TMOD |= 0x00;                //定时器1为模式0(16位自动重载)
 164   1          TL1 = (65536 - (FOSC/4/baud));   //设置波特率重装值
 165   1          TH1 = (65536 - (FOSC/4/baud))>>8;
 166   1          TR1 = 1;                    //定时器1开始启动
 167   1          ES = 1;                     //使能串口中断
 168   1          EA = 1;
 169   1        }
 170          
 171            //串口2初始化
 172            void Init_uart2(unsigned int baud){
 173   1          
 174   1          #if (UART2_IO == 0)
 175   1            P_SW2 &= ~S2_S0;            //S2_S0=0 (P1.0/RxD2, P1.1/TxD2)
 176   1          #elif (UART2_IO==1)
                    P_SW2 |= S2_S0;           //S2_S0=1 (P4.6/RxD2_2, P4.7/TxD2_2)
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2024 01:15:55 PAGE 4   

                  #endif
 179   1          #if (UART2_PARITYBIT == NONE_PARITY)
 180   1              S2CON = 0x50;               //8位可变波特率
 181   1          #elif (UART2_PARITYBIT == ODD_PARITY) || (UART2_PARITYBIT == EVEN_PARITY) || (UART2_PARITYBIT == MARK_PA
             -RITY)
                      S2CON = 0xda;               //9位可变波特率,校验位初始为1
                  #elif (UART2_PARITYBIT == SPACE_PARITY)
                      S2CON = 0xd2;               //9位可变波特率,校验位初始为0
                  #endif
 186   1          T2L = (65536 - (FOSC/4/baud));   //设置波特率重装值
 187   1          T2H = (65536 - (FOSC/4/baud))>>8;
 188   1          AUXR |= 0x14;                    //T2为1T模式, 并启动定时器2
 189   1          IE2 |= 0x01;                     //使能串口2中断
 190   1          EA = 1;                          //开启总中断
 191   1        }
 192            
 193            //发送串口1数据
 194            void UART1_SendData(unsigned char dat)
 195            {
 196   1            while (tx1_busy);               //等待前面的数据发送完成
 197   1            ACC = dat;                  //获取校验位P (PSW.0)
 198   1            if (P)                      //根据P来设置校验位
 199   1            {
 200   2              #if (UART1_PARITYBIT == ODD_PARITY)
                              TB8 = 0;                //设置校验位为0
                      #elif (UART1_PARITYBIT == EVEN_PARITY)
                              TB8 = 1;                //设置校验位为1
                      #endif
 205   2            }
 206   1            else
 207   1            {
 208   2              #if (UART1_PARITYBIT == ODD_PARITY)
                              TB8 = 1;                //设置校验位为1
                      #elif (UART1_PARITYBIT == EVEN_PARITY)
                              TB8 = 0;                //设置校验位为0
                      #endif
 213   2            }
 214   1            tx1_busy = 1;
 215   1            SBUF = ACC;                 //写数据到UART数据寄存器
 216   1        }
 217            //串口1发送字符串
 218            void UART1_SendString(char *s){
 219   1          while (*s)                  //检测字符串结束标志
 220   1          {
 221   2            UART1_SendData(*s++);         //发送当前字符
 222   2          }
 223   1        }
 224            
 225            //发送串口2数据
 226            void UART2_SendData(unsigned char dat){
 227   1            while(tx2_busy);               //等待前面的数据发送完成
 228   1            ACC = dat;                  //获取校验位P (PSW.0)
 229   1            if(P)                       //根据P来设置校验位
 230   1            {
 231   2        #if (UART2_PARITYBIT == ODD_PARITY)
                        S2CON &= ~S2TB8;        //设置校验位为0
                #elif (UART2_PARITYBIT == EVEN_PARITY)
                        S2CON |= S2TB8;         //设置校验位为1
                #endif
 236   2            }
 237   1            else
 238   1            {
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2024 01:15:55 PAGE 5   

 239   2        #if (UART2_PARITYBIT == ODD_PARITY)
                        S2CON |= S2TB8;         //设置校验位为1
                #elif (UART2_PARITYBIT == EVEN_PARITY)
                        S2CON &= ~S2TB8;        //设置校验位为0
                #endif
 244   2            }
 245   1            tx2_busy = 1;
 246   1            S2BUF = ACC;                //写数据到UART2数据寄存器
 247   1        }
 248          
 249            //串口2发送字符串
 250            void UART2_SendString(char *s){
 251   1          while (*s)                  //检测字符串结束标志
 252   1          {
 253   2            UART2_SendData(*s++);         //发送当前字符
 254   2          }
 255   1        }
 256              
 257            
 258            //重定义
 259            char putchar(char ch){
 260   1            PRINTF(ch);
 261   1            return ch;
 262   1        }
 263            
 264            //上报打印
 265            void report_printf(const char *fmt,...)  
 266            {  
 267   1            va_list ap;  
 268   1            char xdata string[20];
 269   1            va_start(ap,fmt);  
 270   1            vsprintf(string,fmt,ap);//此处也可以使用sprintf函数，用法差不多，稍加修改即可，此处略去  
 271   1            REPORT(string);  
 272   1            va_end(ap);  
 273   1        } 
 274          
 275            void UART1_Routine() interrupt 4 using 2
 276            {
 277   1          if (RI)
 278   1          {
 279   2              RI = 0;                 //清除RI位
 280   2              cmd_last = cmd;
 281   2              cmd = SBUF;
 282   2          }
 283   1          if (TI)
 284   1          {
 285   2              TI = 0;                 //清除TI位
 286   2              tx1_busy = 0;               //清忙标志
 287   2          } 
 288   1        }
 289            
 290            //UART2 中断服务程序
 291            void UART2_Routine() interrupt 8 using 3
 292            {
 293   1          if (S2CON & S2RI)           //接收中断
 294   1          {
 295   2            S2CON &= ~S2RI;         //清除S2RI位
 296   2            
 297   2            
 298   2          }
 299   1          if (S2CON & S2TI)           //发送中断
 300   1          {
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2024 01:15:55 PAGE 6   

 301   2              S2CON &= ~S2TI;         //清除S2TI位
 302   2              tx2_busy = 0;           //清发送忙标志
 303   2          }
 304   1        }
 305          
 306            /**
 307              * @brief  线束检测任务
 308              * @retval 0: 检测完成  其他：错误
 309              */
 310            unsigned char Check_Task(void){
 311   1          line_last = line;
 312   1          if(SA1||SA2||SA3||SA4)        //A组检测
 313   1          {
 314   2            pos[0] = pos[1] = pos[2] = pos[3] = pos[4]
 315   2            = bus[0] = bus[1] = bus[2] = bus[3] = 0;
 316   2            line = 0;
 317   2            if (f_debug){
 318   3              printf("\r\n debug检测内容：\r\n");
 319   3              printf(" A组检测  line = %d\r\n", line);}
 320   2            pos[0] = SA1;pos[1] = SA2;pos[2] = SA3;pos[3] = SA4;
 321   2            pos[4] = 15 - (pos[0]|pos[1]<<1|pos[2]<<2|pos[3]<<3);
 322   2            if (f_debug)
 323   2              printf(" SA1=%d; SA2=%d; SA3=%d; SA4=%d; SA_group=%d\r\n", pos[0],pos[1],pos[2],pos[3],pos[4]);
 324   2            if(pos[4] > 4) {return 1;}
 325   2            bus[0] = A0; bus[1] = A1; bus[2] = A2;
 326   2            bus[3] = bus[0]|bus[1]<<1|bus[2]<<2;
 327   2            if (f_debug)
 328   2              printf(" A0=%d; A1=%d; A2=%d; A210=%d\r\n", bus[0],bus[1],bus[2],bus[3]);
 329   2            
 330   2            line += (bus[3]+8*pos[4]);
 331   2            return 0;
 332   2          }
 333   1          if(SB1||SB2||SB3||SB4)    //B组检测
 334   1          {
 335   2            pos[0] = pos[1] = pos[2] = pos[3] = pos[4]
 336   2            = bus[0] = bus[1] = bus[2] = bus[3] = 0;
 337   2            line = 32;
 338   2            if (f_debug)
 339   2              printf(" B组检测  line = %d\r\n", line);  
 340   2            pos[0] = SB1;pos[1] = SB2;pos[2] = SB3;pos[3] = SB4;
 341   2            pos[4] = 15 - (pos[0]|pos[1]<<1|pos[2]<<2|pos[3]<<3);
 342   2            if (f_debug)
 343   2              printf(" SB1=%d; SB2=%d; SB3=%d; SB4=%d; SB_group=%d\r\n", pos[0],pos[1],pos[2],pos[3],pos[4]);
 344   2            if(pos[4] > 4) {return 2;}
 345   2            bus[0] = B0; bus[1] = B1; bus[2] = B2;
 346   2            bus[3] = bus[0]|bus[1]<<1|bus[2]<<2;
 347   2            if (f_debug)
 348   2              printf(" B0=%d; B1=%d; B2=%d; B210=%d\r\n", bus[0],bus[1],bus[2],bus[3]);
 349   2            line += (bus[3]+8*pos[4]);
 350   2            return 0;
 351   2          }
 352   1          if(SC1||SC2||SC3||SC4)    //C组检测
 353   1          {
 354   2            pos[0] = pos[1] = pos[2] = pos[3] = pos[4]
 355   2            = bus[0] = bus[1] = bus[2] = bus[3] = 0;
 356   2            line = 64;
 357   2            if (f_debug)
 358   2              printf(" C组检测  line = %d\r\n", line);
 359   2            pos[0] = SC1;pos[1] = SC2;pos[2] = SC3;pos[3] = SC4;
 360   2            pos[4] = 15 - (pos[0]|pos[1]<<1|pos[2]<<2|pos[3]<<3);
 361   2            if (f_debug)
 362   2              printf(" SC1=%d; SC2=%d; SC3=%d; SC4=%d; SC_group=%d\r\n", pos[0],pos[1],pos[2],pos[3],pos[4]);
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2024 01:15:55 PAGE 7   

 363   2            if(pos[4] > 4) {return 3;}
 364   2            bus[0] = C0; bus[1] = C1; bus[2] = C2;
 365   2            bus[3] = bus[0]|bus[1]<<1|bus[2]<<2;
 366   2            if (f_debug)
 367   2              printf(" C0=%d; C1=%d; C2=%d; C210=%d\r\n", bus[0],bus[1],bus[2],bus[3]);
 368   2            line += (bus[3]+8*pos[4]);
 369   2            return 0;
 370   2          }
 371   1          if(SD1||SD2||SD3||SD4)    //D组检测
 372   1          {
 373   2            pos[0] = pos[1] = pos[2] = pos[3] = pos[4]
 374   2            = bus[0] = bus[1] = bus[2] = bus[3] = 0;
 375   2            line = 96;
 376   2            if (f_debug)
 377   2              printf(" D组判断  line = %d\r\n", line);
 378   2            pos[0] = SD1;pos[1] = SD2;pos[2] = SD3;pos[3] = SD4;
 379   2            pos[4] = 15 - (pos[0]|pos[1]<<1|pos[2]<<2|pos[3]<<3);
 380   2            if (f_debug)
 381   2              printf(" SD1=%d; SD2=%d; SD3=%d; SD4=%d; SD_group=%d\r\n", pos[0],pos[1],pos[2],pos[3],pos[4]);
 382   2            if(pos[4] > 4) {return 4;}
 383   2            bus[0] = D0; bus[1] = D1; bus[2] = D2;
 384   2            bus[3] = bus[0]|bus[1]<<1|bus[2]<<2;
 385   2            if (f_debug)
 386   2            printf(" D0=%d; D1=%d; D2=%d; D210=%d\r\n", bus[0],bus[1],bus[2],bus[3]);
 387   2            line += (bus[3]+8*pos[4]);
 388   2            return 0;
 389   2          }
 390   1          if(SE1||SE2||SE3)   //E组检测
 391   1          {
 392   2            pos[0] = pos[1] = pos[2] = pos[3] = pos[4]
 393   2            = bus[0] = bus[1] = bus[2] = bus[3] = 0;
 394   2            line = 128;
 395   2            if (f_debug)
 396   2            printf(" E组检测  line = %d\r\n", line);
 397   2            pos[0] = SE1;pos[1] = SE2;pos[2] = SE3;
 398   2            pos[4] = 15 - (pos[0]|pos[1]<<1|pos[2]<<2);
 399   2            if (f_debug)
 400   2            printf(" SE1=%d; SE2=%d; SE3=%d; SE_group=%d\r\n", pos[0],pos[1],pos[2],pos[4]);
 401   2            if(pos[4] > 3) {return 5;}
 402   2            bus[0] = E0; bus[1] = E1; bus[2] = E2;
 403   2            bus[3] = bus[0]|bus[1]<<1|bus[2]<<2;
 404   2            if (f_debug)
 405   2            printf(" E0=%d; E1=%d; E2=%d; E210=%d\r\n", bus[0],bus[1],bus[2],bus[3]);
 406   2            line += (bus[3]+8*pos[4]);
 407   2            return 0;
 408   2          }
 409   1          return 0;
 410   1        }
 411          
 412            /**
 413              * @brief  初始化打印
 414              */
 415            void Printf_Init(void){
 416   1          char i;
 417   1          printf("\r\n");
 418   1          printf("Loading...\r\n");
 419   1          for(i=0;i<50;i++)
 420   1          {
 421   2            printf("=");
 422   2            delay_us(50);
 423   2          }
 424   1          printf("\r\n");
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2024 01:15:55 PAGE 8   

 425   1          printf(" _    _             ___ _           _    \r\n");
 426   1          printf("| |  (_)_ _  ___   / __| |_  ___ __| |__ \r\n"); 
 427   1          printf("| |__| | ' \\/ -_) | (__| ' \\/ -_) _| / / \r\n");
 428   1          printf("|____|_|_||_\\___|  \\___|_||_\\___\\__|_\\_\\ \r\n");
 429   1          printf("\r\n");
 430   1          printf("Version:      V1.0.1      \r\n");
 431   1          printf("Author:       Gsx         \r\n");
 432   1          printf("芯片信息:     STC15F2K60S2\r\n");
 433   1          printf("系统主频:     %ld\r\n", FOSC);
 434   1          printf("波特率:       %d\r\n", UART2_BODE);
 435   1          printf("输入0x04查看指令帮助      \r\n");
 436   1        }
 437            /**
 438              * @brief  报错打印
 439              */
 440            void Err_printf(void){
 441   1          switch(err)
 442   1          {
 443   2            case 1:
 444   2            {
 445   3              printf("\r\nError(1): SA1 ~ SA4线出错,已停止检测\r\n");
 446   3            }break;
 447   2            case 2:
 448   2            {
 449   3              printf("\r\nError(2): SB1 ~ SB4线出错,已停止检测\r\n");
 450   3            }break;
 451   2            case 3:
 452   2            {
 453   3              printf("\r\nError(3): SC1 ~ SC4线出错,已停止检测\r\n");
 454   3            }break;
 455   2            case 4:
 456   2            {
 457   3              printf("\r\nError(4): SD1 ~ SD4线出错,已停止检测\r\n");
 458   3            }break;
 459   2            case 5:
 460   2            {
 461   3              printf("\r\nError(5): SE1 ~ SE3线出错,已停止检测\r\n");
 462   3            }break;
 463   2            default:
 464   2            break;
 465   2          }
 466   1        }
 467          
 468            /**
 469              * @brief  初始化任务
 470              */
 471            void Init_Task(void){
 472   1          
 473   1          Init_uart2(UART2_BODE);
 474   1          Init_uart1(UART1_BODE);
 475   1          Printf_Init();
 476   1        }
 477          
 478            /**
 479              * @brief  打印任务
 480              */
 481            void Printf_Task(void){
 482   1            if(!err){
 483   2              if(line==-1)
 484   2              {
 485   3                printf("\r\n没有线被拉低。\r\n");
 486   3                report_printf("ff");
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2024 01:15:55 PAGE 9   

 487   3              }
 488   2              else{
 489   3                printf("\r\n%d线被拉低。\r\n", line);
 490   3                report_printf("%d",(int)line);    //上报
 491   3                line = -1;
 492   3              }
 493   2            }else
 494   1            {
 495   2              Err_printf();
 496   2              report_printf("ff%d", (int)err);
 497   2            }
 498   1        }
 499            
 500            void main(void)
 501            {
 502   1          Init_Task();
 503   1          while (1)
 504   1          { 
 505   2            if(cmd!=BOOT)
 506   2            {
 507   3              switch (cmd)
 508   3              {
 509   4                case STEP:
 510   4                {
 511   5                  cmd = BOOT;
 512   5                  err_last = err;
 513   5                  err = Check_Task();
 514   5                  Printf_Task();
 515   5                }
 516   4                break;
 517   4                case ROLL:
 518   4                {
 519   5                  err_last = err;
 520   5                  err = Check_Task();
 521   5                  Printf_Task();
 522   5                }
 523   4                break;
 524   4                case DEBUG:
 525   4                {
 526   5                  f_debug = ~f_debug;
 527   5                  if(f_debug)printf("\r\nDEBUG已开启\r\n");
 528   5                  else printf("\r\nDEBUG已关闭\r\n");
 529   5                  cmd = cmd_last;
 530   5                }
 531   4                break;
 532   4                case HELP:
 533   4                {
 534   5                  printf("\r\n");
 535   5                  printf("*============ CMD LIST ============*\r\n");
 536   5                  printf(" 0x00----------BOOT停止指令         \r\n");
 537   5                  printf(" 0x01----------STEEP单步测试指令    \r\n");
 538   5                  printf(" 0x02----------ROLL滚动测试指令     \r\n");
 539   5                  printf(" 0x03----------DEBUG开关debug指令   \r\n");
 540   5                  printf(" 0x04----------HELP指令列表         \r\n");
 541   5                  printf(" 0x05----------REBOOT重启           \r\n");
 542   5                  printf(" 0x06----------AUTO自动检测         \r\n");
 543   5                  cmd = BOOT;
 544   5                }
 545   4                break;
 546   4                case REBOOT:
 547   4                {
 548   5                  pos[0] = pos[1] = pos[2] = pos[3] = pos[4]
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2024 01:15:55 PAGE 10  

 549   5                  = bus[0] = bus[1] = bus[2] = bus[3] = 0;
 550   5                  line = 0;
 551   5                  Printf_Init();
 552   5                  cmd = BOOT;
 553   5                }
 554   4                break;
 555   4                case AUTO:
 556   4                {
 557   5                  err_last = err;
 558   5                  err = Check_Task();
 559   5                  
 560   5                  if(err_last!=err || line_last!= line)
 561   5                  {
 562   6                    Printf_Task();
 563   6                  }
 564   5                }
 565   4                break;
 566   4                default:
 567   4                  break;
 568   4              }
 569   3            }
 570   2            
 571   2          }
 572   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2738    ----
   CONSTANT SIZE    =   1454    ----
   XDATA SIZE       =   ----      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26      32
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
