#include <REG51.H>
#include "intrins.h"

#define uint16 unsigned int 
#define uint8 unsigned char 
	

sbit A_H = P1^0;
sbit A_L = P1^1;
sbit B_H = P1^2;
sbit B_L = P1^3;
sbit C_H = P1^4;
sbit C_L = P1^5;

sbit KEY_UP = P2^5;
sbit KEY_DOWN = P2^7;



/*正弦函数查表*/
signed int code spwm[]={
1,5,9,13,17,21,25,29,33,37,41,44,48,52,56,60,64,67,71,75,79,82,86,90,93,97,101,104,108,111,115,118,122,125,128,132,
135,138,142,145,148,151,154,157,160,163,166,169,172,175,178,180,183,186,188,191,193,196,198,201,203,205,207,209,212,
214,216,218,219,221,223,225,226,228,230,231,233,234,235,237,238,239,240,241,242,243,244,245,245,246,247,247,248,248,
248,249,249,249,249,249,249,249,249,249,249,248,248,248,247,247,246,245,245,244,243,242,241,240,239,238,237,235,234,
233,231,230,228,226,225,223,221,219,218,216,214,212,209,207,205,203,201,198,196,193,191,188,186,183,180,178,175,172,
169,166,163,160,157,154,151,148,145,142,138,135,132,128,125,122,118,115,111,108,104,101,97,93,90,86,82,79,75,71,67,64,
60,56,52,48,44,41,37,33,29,25,21,17,13,9,5,1,-2,-6,-10,-14,-18,-22,-26,-30,-34,-38,-42,-45,-49,-53,-57,-61,-65,-68,-72,
-76,-80,-83,-87,-91,-94,-98,-102,-105,-109,-112,-116,-119,-123,-126,-129,-133,-136,-139,-143,-146,-149,-152,-155,-158,
-161,-164,-167,-170,-173,-176,-179,-181,-184,-187,-189,-192,-194,-197,-199,-202,-204,-206,-208,-210,-213,-215,-217,-219,
-220,-222,-224,-226,-227,-229,-231,-232,-234,-235,-236,-238,-239,-240,-241,-242,-243,-244,-245,-246,-246,-247,-248,-248,
-249,-249,-249,-250,-250,-250,-250,-250,-250,-250,-250,-250,-250,-249,-249,-249,-248,-248,-247,-246,-246,-245,-244,-243,
-242,-241,-240,-239,-238,-236,-235,-234,-232,-231,-229,-227,-226,-224,-222,-220,-219,-217,-215,-213,-210,-208,-206,-204,
-202,-199,-197,-194,-192,-189,-187,-184,-181,-179,-176,-173,-170,-167,-164,-161,-158,-155,-152,-149,-146,-143,-139,-136,
-133,-129,-126,-123,-119,-116,-112,-109,-105,-102,-98,-94,-91,-87,-83,-80,-76,-72,-68,-65,-61,-57,-53,-49,-45,-42,-38,-
34,-30,-26,-22,-18,-14,-10,-6,-2
};

void Delay_ms(int t)
{
	unsigned char n, m;
	while(t--){
		n = 12;
		m = 169;
		do
		{
			while (--m);
		} while (--n);
	}
}

int F_r,F_c,Ts,j,flag;
int cnt = 0;
int a_i = 0,b_i=134,c_i=266;

//使用异步调制，载波频率为2000Hz
void main(void)
{
	F_c = 2000; //载波频率(Hz)
	F_r = 1; 	 //SPWM频率(Hz)
	Ts = 2.5*(F_c/F_r);//根据步长设定调制波取20个点，将一个调制波分为4等分，每等分瞬时变化最大值为250，
	TMOD |= 0x10;	//模式1(16位定时器)
	TH1 = (65536-Ts)/256;	
	TL1 = (65536-Ts)%256;
	PT1 = 1;
	ET1 = 1;
	
	EA  = 1;
	
	TR1 = 1;
	KEY_UP = 1;
	KEY_DOWN = 1;
	
	
	//Delay_ms(5000);
	
	while(1)
	{
		if(!KEY_UP)
		{
			_nop_();_nop_();
			if(!KEY_UP)
			{
				F_r += 1;
				if(F_r>50)F_r = 50;
				Ts  = 2500/F_r;
			}
		}
		if(!KEY_DOWN)
		{
			_nop_();_nop_();
			if(!KEY_DOWN)
			{
				F_r -= 1;
				if(F_r<1)F_r = 0;
				Ts  = 2500/F_r;
			}
		}
	}
}

void Timer1_ISR() interrupt 3 using 1
{
	TH1 = (65536-Ts)/256;
	TL1 = (65536-Ts)%256;
	//比较载波与调制波
	//A相
	if(cnt<=spwm[a_i])
	{
		A_L=0; 
		for(j=2;j>0;j--);	//延时5us产生死区
		A_H=1;
	}
	if(cnt>spwm[a_i])
	{
		A_H=0; 
		for(j=2;j>0;j--); //延时5us产生死区
		A_L=1;
	}
	//B相
	if(cnt<=spwm[b_i])
	{
		B_L=0; 
		for(j=2;j>0;j--);	//延时5us产生死区
		B_H=1;
	}
	if(cnt>spwm[b_i])
	{
		B_H=0; 
		for(j=2;j>0;j--); //延时5us产生死区
		B_L=1;
	}
	//C相
	if(cnt<=spwm[c_i])
	{
		C_L=0; 
		for(j=2;j>0;j--);	//延时5us产生死区
		C_H=1;
	}
	if(cnt>spwm[c_i])
	{
		C_H=0; 
		for(j=2;j>0;j--); //延时5us产生死区
		C_L=1;
	}	
	
	//判断载波上升还是下降
	if(flag)
		cnt += Ts;		
	else						
		cnt -= Ts;		
	//判断cnt是否达到最高值或最低值，并置flag
	if(cnt > 250)
	{
		cnt = 250;
		flag=0;
	}
	if(cnt<-250) 
	{
		cnt = -250;
		flag=1;
	}
	//spwm索引递增
	a_i++;
	if(a_i==400)//索引越界判断
	{
		a_i=0;
	}
	b_i++;
	if(b_i==400)//索引越界判断
	{
		b_i=0;
	}
	c_i++;
	if(c_i==400)//索引越界判断
	{
		c_i=0;
	}
}



